[
  {
    "id" : "9ac4b9b6-5208-4e94-b801-ca26508c421a",
    "prId" : 2749,
    "prUrl" : "https://github.com/scalameta/metals/pull/2749",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27d2bc46-42c3-46ba-a244-cf6f74b774aa",
        "parentId" : null,
        "authorId" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "body" : "The reason might be that targetroot seems to be a fallback now:\r\nhttps://github.com/scalacenter/scalafix/blob/bf0df227c9b72fd6a9466f3a6fe11a8ce5f14efd/scalafix-cli/src/main/scala/scalafix/internal/v1/Args.scala#L365",
        "createdAt" : "2021-04-30T14:00:35Z",
        "updatedAt" : "2021-04-30T14:00:36Z",
        "lastEditedBy" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "tags" : [
        ]
      },
      {
        "id" : "a587416c-3120-44db-9484-7f7a3e485710",
        "parentId" : "27d2bc46-42c3-46ba-a244-cf6f74b774aa",
        "authorId" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "body" : "I wouldn't say it's a fallback, it's just what this method does`getResourceAsStream` \r\n```\r\nprivate[scalafix] def fromPath(....) = {\r\n\r\nOption(classLoader.getResourceAsStream(semanticdbRelPath))\r\n...\r\n\r\n}\r\n```",
        "createdAt" : "2021-04-30T14:53:42Z",
        "updatedAt" : "2021-04-30T14:54:04Z",
        "lastEditedBy" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "tags" : [
        ]
      },
      {
        "id" : "983c67f9-0ff8-4c3f-8f6c-02bb1dbca23a",
        "parentId" : "27d2bc46-42c3-46ba-a244-cf6f74b774aa",
        "authorId" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "body" : "We always look for semanticdb files in the classpath provided.\r\n",
        "createdAt" : "2021-04-30T14:55:56Z",
        "updatedAt" : "2021-04-30T14:55:57Z",
        "lastEditedBy" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "tags" : [
        ]
      },
      {
        "id" : "5dcee0a3-edcc-4144-9dc9-3e9531229adf",
        "parentId" : "27d2bc46-42c3-46ba-a244-cf6f74b774aa",
        "authorId" : "43e93173-6a0c-470b-b449-2889fd9eb639",
        "body" : "huh interesting. I've seen an increased number of Vim users report seeing this lately:\r\n```\r\nLSP[metals] Stale SemanticDB\r\n--- /Users/REDACTED/Developer/REDACTED/package.scala-ondisk-md5-fingerprint\r\n+++ /Users/REDACTED/Developer/REDACTED/package.scala-semanticdb-md5-fingerprint\r\n@@ -1,1 +1,1 @@\r\n-91644521E64C92BC49FE92CF9078677E\r\n```\r\nThis should potentially help with this change right?",
        "createdAt" : "2021-04-30T19:46:55Z",
        "updatedAt" : "2021-04-30T19:47:23Z",
        "lastEditedBy" : "43e93173-6a0c-470b-b449-2889fd9eb639",
        "tags" : [
        ]
      },
      {
        "id" : "dd24d180-68de-44b2-9748-c59b5c4fbe2d",
        "parentId" : "27d2bc46-42c3-46ba-a244-cf6f74b774aa",
        "authorId" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "body" : "I think so, we always looked on the classpath first, which meant we could pick up old semanticdb artifacts in case of any config changes,",
        "createdAt" : "2021-04-30T19:52:23Z",
        "updatedAt" : "2021-04-30T19:52:23Z",
        "lastEditedBy" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "65eabc83bcf2a01571553acde612dc2116c8a6d3",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +158,162 @@    // It seems that Scalafix ignores the targetroot parameter and searches the classpath\n    // Prepend targetroot to make sure that it's picked up first always\n    val classpath =\n      (targetRoot.toList ++ scalaTarget.fullClasspath.asScala).asJava\n"
  },
  {
    "id" : "6079cc91-e6bd-4d63-9474-872567596da1",
    "prId" : 2119,
    "prUrl" : "https://github.com/scalameta/metals/pull/2119",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74fec3f0-2c0a-433d-848b-478cfeeba07a",
        "parentId" : null,
        "authorId" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "body" : "I would change this for comprehension from option to Try to get errors when failing downloading scalafix or the rule. It will also be easier to add error message on other part.\r\n```\r\n  private def getScalafix(\r\n      scalaBinaryVersion: ScalaBinaryVersion\r\n  ): Try[Scalafix] = {\r\n    scalafixCache\r\n      .get(scalaBinaryVersion)\r\n      .toTry\r\n      .orElse(\r\n        statusBar.trackBlockingTask(\"Downloading scalafix\") {\r\n          Try(Scalafix.fetchAndClassloadInstance(scalaBinaryVersion))\r\n            .map { api =>\r\n              scalafixCache.update(scalaBinaryVersion, api)\r\n              api\r\n            }\r\n        }\r\n      )\r\n  }\r\n\r\n  private def getRuleClassLoader(\r\n      scalaBinaryVersion: ScalaBinaryVersion,\r\n      scalafixClassLoader: ClassLoader\r\n  ): Try[URLClassLoader] = {\r\n    val pathsOpt = organizeImportRuleCache\r\n      .get(scalaBinaryVersion)\r\n      .toTry\r\n      .orElse(\r\n        statusBar.trackBlockingTask(\"Downloading organize import rule\") {\r\n          Try(Embedded.organizeImportRule(scalaBinaryVersion))\r\n            .map { paths =>\r\n              organizeImportRuleCache.update(scalaBinaryVersion, paths)\r\n              paths\r\n            }\r\n        }\r\n      )\r\n    pathsOpt.map(paths =>\r\n      Embedded.toClassLoader(\r\n        Classpath(paths.map(AbsolutePath(_))),\r\n        scalafixClassLoader\r\n      )\r\n    )\r\n  }\r\n// to add with the rest of extension methods we have on Option.\r\n  implicit class OptionExtension[A](val in: Option[A]) extends AnyVal {\r\n    def toTry(e: => Throwable): Try[A] = in match {\r\n      case Some(v) => Success(v)\r\n      case None => Failure(e)\r\n    }\r\n\r\n    def toTry = toTry(new Exception(\"None.get \"))\r\n  \r\n```\r\n\r\nThis way we will cover this error. ",
        "createdAt" : "2020-10-05T11:07:33Z",
        "updatedAt" : "2020-10-05T17:36:58Z",
        "lastEditedBy" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "tags" : [
        ]
      },
      {
        "id" : "349ce6f4-560d-418c-b2c3-f0ca4761169e",
        "parentId" : "74fec3f0-2c0a-433d-848b-478cfeeba07a",
        "authorId" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "body" : "Thanks, I changed it a bit, but stayed why Try as you suggested.",
        "createdAt" : "2020-10-05T17:09:09Z",
        "updatedAt" : "2020-10-05T17:36:58Z",
        "lastEditedBy" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b271a278ae2c881051a18b72dc1b1f97da8cb4cb",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +57,61 @@        val scalaBinaryVersion = scalaTarget.scalaBinaryVersion\n        val scalafixEvaluation = for {\n          api <- getScalafix(scalaBinaryVersion)\n          urlClassLoaderWithExternalRule <- getRuleClassLoader(\n            scalaBinaryVersion,"
  },
  {
    "id" : "4a1b6892-d551-4c64-acbf-64d4e7913bac",
    "prId" : 2119,
    "prUrl" : "https://github.com/scalameta/metals/pull/2119",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a2bcc35-cd44-4702-8a57-f85dafe7c2cb",
        "parentId" : null,
        "authorId" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "body" : "Changed it to Classlaoder, since otherwise we create a new classlaoder on each run, which can really grow the memory.",
        "createdAt" : "2020-10-06T10:39:28Z",
        "updatedAt" : "2020-10-06T10:39:28Z",
        "lastEditedBy" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b271a278ae2c881051a18b72dc1b1f97da8cb4cb",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +34,38 @@  private val scalafixCache = TrieMap.empty[ScalaBinaryVersion, Scalafix]\n  private val organizeImportRuleCache =\n    TrieMap.empty[ScalaBinaryVersion, URLClassLoader]\n\n  def organizeImports("
  },
  {
    "id" : "f2d4870d-c821-4eaf-8d03-d414c34265b4",
    "prId" : 1971,
    "prUrl" : "https://github.com/scalameta/metals/pull/1971",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "405586a9-1696-439b-a58d-7b78fa60e6f5",
        "parentId" : null,
        "authorId" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "body" : "Should we not use concurrent map here? What if someone quickly runs optimize imports a couple of times? We should wait and not run additional times",
        "createdAt" : "2020-09-14T18:40:52Z",
        "updatedAt" : "2020-09-25T12:46:58Z",
        "lastEditedBy" : "a7ecab15-7126-4839-9885-ed1a3031e6b8",
        "tags" : [
        ]
      },
      {
        "id" : "cbcba096-8186-4c35-a8f3-b44066fc6bde",
        "parentId" : "405586a9-1696-439b-a58d-7b78fa60e6f5",
        "authorId" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "body" : "We decided to keep TrieMap after discussing it.",
        "createdAt" : "2020-09-25T12:43:10Z",
        "updatedAt" : "2020-09-25T12:46:58Z",
        "lastEditedBy" : "da2cd095-1f8f-45c7-9ea4-3315cad4b0b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f623f507d61ccbcd02d982594a8b0d46c292509",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +103,107 @@          Try(Scalafix.fetchAndClassloadInstance(scalaBinaryVersion)).toOption\n            .map { api =>\n              scalafixCache.update(scalaBinaryVersion, api)\n              api\n            }"
  }
]